/*
========================================================================================
    Config file for defining DSL2 per module options and publishing paths
========================================================================================
*/

process {
    publishDir = [
        path: { "${params.outdir}/${task.process.tokenize(':')[-1].tokenize('_')[0].toLowerCase()}" },
        mode: params.publish_dir_mode,
        saveAs: { filename -> filename.equals('versions.yml') ? null : filename }
    ]

    // Input validation modules
    withName: 'CHECK_VCF_FORMAT' {
        publishDir = [
            path: { "${params.outdir}/validation" },
            mode: params.publish_dir_mode,
            pattern: "*.{txt,log}"
        ]
    }

    // QC modules - BCFtools processes
    withName: 'REMOVE_DUPLICATES|SPLIT_MULTIALLELIC|FILTER_VARIANTS|CHECK_VCF_FORMAT' {
        container = 'mamana/vcf-processing:bcftools-1.20'
        ext.args = '--output-type z'
        publishDir = [
            path: { "${params.outdir}/qc" },
            mode: params.publish_dir_mode,
            pattern: "*.vcf.gz*"
        ]
    }

    withName: 'CHECK_HWE|VALIDATE_CHROMOSOMES|CHECK_SAMPLE_OVERLAP|CALCULATE_MISSINGNESS|ANNOTATE_VARIANTS|CHECK_REFERENCE_COMPATIBILITY' {
        container = 'mamana/vcf-processing:bcftools-1.20'
        publishDir = [
            path: { "${params.outdir}/qc" },
            mode: params.publish_dir_mode,
            pattern: "*.{txt,log}"
        ]
    }

    // Phasing modules
    withName: 'EAGLE_PHASE' {
        container = 'mamana/eagle-vcf-processing:eagle-2.4.1'
        ext.args = '--pbwtIters 2 --numThreads 4'
        cpus = { check_max(4 * task.attempt, 'cpus') }
        memory = { check_max(16.GB * task.attempt, 'memory') }
        time = { check_max(12.h * task.attempt, 'time') }
        publishDir = [
            path: { "${params.outdir}/phased" },
            mode: params.publish_dir_mode,
            pattern: "*.phased.vcf.gz*"
        ]
    }

    withName: 'SHAPEIT_PHASE' {
        container = 'mamana/phasing:shapeit4-4.2.2'
        ext.args = '--burn 7 --prune 8 --main 20'
        cpus = { check_max(8 * task.attempt, 'cpus') }
        memory = { check_max(24.GB * task.attempt, 'memory') }
    }

    withName: 'BEAGLE_PHASE' {
        container = 'mamana/phasing:beagle-5.4'
        cpus = { check_max(4 * task.attempt, 'cpus') }
        memory = { check_max(16.GB * task.attempt, 'memory') }
    }

    // VCF processing modules  
    withName: 'MERGE_PHASED_CHUNKS|MERGE_IMPUTED_CHUNKS' {
        container = 'mamana/vcf-processing:bcftools-1.20'
        publishDir = [
            path: { "${params.outdir}/merged" },
            mode: params.publish_dir_mode,
            pattern: "*.merged.vcf.gz*"
        ]
    }

    // Imputation modules
    withName: 'MINIMAC4_IMPUTE' {
        container = 'mamana/imputation:minimac4-4.1.6'
        ext.args = '--format GT,DS,GP,HDS --noPhoneHome'
        cpus = { check_max(4 * task.attempt, 'cpus') }
        memory = { check_max(32.GB * task.attempt, 'memory') }
        time = { check_max(24.h * task.attempt, 'time') }
        publishDir = [
            path: { "${params.outdir}/imputed" },
            mode: params.publish_dir_mode,
            pattern: "*.dose.vcf.gz*",
            saveAs: { filename -> 
                def meta_str = "${meta.id}_${meta.chr ?: 'all'}"
                filename.replace(meta.id, meta_str)
            }
        ]
    }

    withName: 'EXTRACT_INFO_SCORES|FILTER_IMPUTED' {
        container = 'mamana/vcf-processing:bcftools-1.20'
        publishDir = [
            path: { "${params.outdir}/imputed" },
            mode: params.publish_dir_mode,
            pattern: "*.{txt,vcf.gz*}"
        ]
    }

    withName: 'IMPUTE5_IMPUTE' {
        ext.args = '--out-gp-field --out-ap-field'
        cpus = { check_max(2 * task.attempt, 'cpus') }
        memory = { check_max(8.GB * task.attempt, 'memory') }
        container = 'mamana/imputation:minimac4-4.1.6'
    }

    withName: 'BEAGLE5_IMPUTE' {
        container = 'mamana/phasing:beagle-5.4'
        ext.args = 'gp=true ap=true'
        cpus = { check_max(4 * task.attempt, 'cpus') }
        memory = { check_max(16.GB * task.attempt, 'memory') }
    }

    // VCF chunking
    withName: 'CHUNK_GENOME' {
        container = 'mamana/python-plotting:1.0.0'
        publishDir = [
            path: { "${params.outdir}/chunks" },
            mode: params.publish_dir_mode,
            pattern: "*.bed"
        ]
    }

    // Reporting and visualization modules
    withName: 'CALCULATE_METRICS|CALCULATE_IMPUTATION_METRICS' {
        container = 'mamana/python-plotting:1.0.0'
        cpus = 2
        memory = 8.GB
        publishDir = [
            path: { "${params.outdir}/metrics" },
            mode: params.publish_dir_mode,
            pattern: "*.{json,tsv,txt}"
        ]
    }

    withName: 'ACCURACY_REPORT|PERFORMANCE_REPORT|HTML_REPORT|MULTIQC_CONFIG' {
        container = 'mamana/python-plotting:latest'
        cpus = 1
        memory = 4.GB
        publishDir = [
            path: { "${params.outdir}/reports" },
            mode: params.publish_dir_mode,
            pattern: "*.{html,pdf,png}"
        ]
    }

    withName: 'PLOT_INFO_DISTRIBUTION|PLOT_MAF_CONCORDANCE|PLOT_R2_POSITION' {
        container = 'mamana/python-plotting:latest'
        cpus = 1
        memory = 4.GB
        publishDir = [
            path: { "${params.outdir}/plots" },
            mode: params.publish_dir_mode,
            pattern: "*.{png,pdf,svg}"
        ]
    }

    withName: 'CREATE_HTML_REPORT' {
        container = 'mamana/python-plotting:latest'
        cpus = 2
        memory = 8.GB
        publishDir = [
            path: { "${params.outdir}" },
            mode: params.publish_dir_mode,
            pattern: "*.html",
            saveAs: { "imputation_report.html" }
        ]
    }

    // nf-core modules
    withName: 'CUSTOM_DUMPSOFTWAREVERSIONS' {
        container = 'quay.io/biocontainers/python:3.11.0'
        publishDir = [
            path: { "${params.outdir}/pipeline_info" },
            mode: params.publish_dir_mode,
            pattern: "*.{yml,tsv}"
        ]
    }

    // Resource limits for all processes
    withLabel: 'process_single' {
        cpus = { check_max(1, 'cpus') }
        memory = { check_max(2.GB * task.attempt, 'memory') }
        time = { check_max(2.h * task.attempt, 'time') }
    }

    withLabel: 'process_low' {
        cpus = { check_max(2 * task.attempt, 'cpus') }
        memory = { check_max(4.GB * task.attempt, 'memory') }
        time = { check_max(4.h * task.attempt, 'time') }
    }

    withLabel: 'process_medium' {
        cpus = { check_max(4 * task.attempt, 'cpus') }
        memory = { check_max(8.GB * task.attempt, 'memory') }
        time = { check_max(8.h * task.attempt, 'time') }
    }

    withLabel: 'process_high' {
        cpus = { check_max(8 * task.attempt, 'cpus') }
        memory = { check_max(16.GB * task.attempt, 'memory') }
        time = { check_max(16.h * task.attempt, 'time') }
    }

    withLabel: 'process_long' {
        time = { check_max(24.h * task.attempt, 'time') }
    }

    withLabel: 'process_high_memory' {
        memory = { check_max(32.GB * task.attempt, 'memory') }
    }

    // Error handling
    withLabel: 'error_ignore' {
        errorStrategy = 'ignore'
    }

    withLabel: 'error_retry' {
        errorStrategy = 'retry'
        maxRetries = 2
    }
}

// Function to ensure resource requirements don't exceed maximums
def check_max(obj, type) {
    if (type == 'memory') {
        try {
            if (obj.compareTo(params.max_memory as nextflow.util.MemoryUnit) == 1)
                return params.max_memory as nextflow.util.MemoryUnit
            else
                return obj
        } catch (all) {
            println "   ### ERROR ###   Max memory '${params.max_memory}' is not valid! Using default value: $obj"
            return obj
        }
    } else if (type == 'cpus') {
        try {
            return Math.min(obj, params.max_cpus as int)
        } catch (all) {
            println "   ### ERROR ###   Max cpus '${params.max_cpus}' is not valid! Using default value: $obj"
            return obj
        }
    } else if (type == 'time') {
        try {
            if (obj.compareTo(params.max_time as nextflow.util.Duration) == 1)
                return params.max_time as nextflow.util.Duration
            else
                return obj
        } catch (all) {
            println "   ### ERROR ###   Max time '${params.max_time}' is not valid! Using default value: $obj"
            return obj
        }
    }
}