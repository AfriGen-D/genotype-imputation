/*
========================================================================================
    Config file for defining DSL2 per module options and publishing paths
========================================================================================
*/

process {
    publishDir = [
        path: { "${params.outdir}/${task.process.tokenize(':')[-1].tokenize('_')[0].toLowerCase()}" },
        mode: params.publish_dir_mode,
        saveAs: { filename -> filename.equals('versions.yml') ? null : filename }
    ]

    // Input validation modules
    withName: 'CHECK_VCF_FORMAT' {
        publishDir = [
            path: { "${params.outdir}/validation" },
            mode: params.publish_dir_mode,
            pattern: "*.{txt,log}"
        ]
    }

    // QC modules - BCFtools processes
    withName: 'REMOVE_DUPLICATES|SPLIT_MULTIALLELIC|FILTER_VARIANTS|CHECK_VCF_FORMAT' {
        container = 'mamana/vcf-processing:bcftools-1.20'
        ext.args = '--output-type z --threads 8'
        cpus = { check_max(8 * task.attempt, 'cpus') }
        memory = { check_max(32.GB * task.attempt, 'memory') }
        time = { check_max(8.h * task.attempt, 'time') }
        errorStrategy = { task.exitStatus in [137,139,143,247] ? 'retry' : 'finish' }
        maxRetries = 2
        publishDir = [
            path: { "${params.outdir}/qc" },
            mode: params.publish_dir_mode,
            pattern: "*.vcf.gz*"
        ]
    }

    withName: 'CHECK_HWE|VALIDATE_CHROMOSOMES|CHECK_SAMPLE_OVERLAP|CALCULATE_MISSINGNESS|ANNOTATE_VARIANTS|CHECK_REFERENCE_COMPATIBILITY' {
        container = 'mamana/vcf-processing:bcftools-1.20'
        cpus = { check_max(4 * task.attempt, 'cpus') }
        memory = { check_max(16.GB * task.attempt, 'memory') }
        time = { check_max(4.h * task.attempt, 'time') }
        errorStrategy = 'retry'
        maxRetries = 2
        publishDir = [
            path: { "${params.outdir}/qc" },
            mode: params.publish_dir_mode,
            pattern: "*.{txt,log}"
        ]
    }

    // Phasing modules
    withName: 'EAGLE_PHASE' {
        container = 'mamana/eagle-vcf-processing:eagle-2.4.1'
        ext.args = '--pbwtIters 2 --numThreads 16'
        cpus = { check_max(16 * task.attempt, 'cpus') }
        memory = { check_max(64.GB * task.attempt, 'memory') }
        time = { check_max(24.h * task.attempt, 'time') }
        publishDir = [
            path: { "${params.outdir}/phased" },
            mode: params.publish_dir_mode,
            pattern: "*.phased.vcf.gz*"
        ]
    }

    withName: 'SHAPEIT_PHASE' {
        container = 'mamana/phasing:shapeit4-4.2.2'
        ext.args = '--burn 7 --prune 8 --main 20 --thread 16'
        cpus = { check_max(16 * task.attempt, 'cpus') }
        memory = { check_max(64.GB * task.attempt, 'memory') }
        time = { check_max(24.h * task.attempt, 'time') }
        errorStrategy = { task.exitStatus in [137,139,143,247] ? 'retry' : 'terminate' }
        maxRetries = 3
    }

    withName: 'BEAGLE_PHASE' {
        container = 'mamana/phasing:beagle-5.4'
        ext.args = 'nthreads=16'
        cpus = { check_max(16 * task.attempt, 'cpus') }
        memory = { check_max(64.GB * task.attempt, 'memory') }
        time = { check_max(24.h * task.attempt, 'time') }
        errorStrategy = { task.exitStatus in [137,139,143,247] ? 'retry' : 'terminate' }
        maxRetries = 3
    }

    // VCF processing modules  
    withName: 'MERGE_PHASED_CHUNKS|MERGE_IMPUTED_CHUNKS' {
        container = 'mamana/vcf-processing:bcftools-1.20'
        ext.args = '--threads 12'
        cpus = { check_max(12 * task.attempt, 'cpus') }
        memory = { check_max(48.GB * task.attempt, 'memory') }
        time = { check_max(12.h * task.attempt, 'time') }
        errorStrategy = { task.exitStatus in [137,139,143,247] ? 'retry' : 'terminate' }
        maxRetries = 2
        publishDir = [
            path: { "${params.outdir}/merged" },
            mode: params.publish_dir_mode,
            pattern: "*.merged.vcf.gz*"
        ]
    }

    // Imputation modules
    withName: 'MINIMAC4_IMPUTE' {
        container = 'mamana/imputation:minimac4-4.1.6'
        ext.args = '--format GT,DS,GP,HDS --noPhoneHome --cpus 16'
        cpus = { check_max(16 * task.attempt, 'cpus') }
        memory = { check_max(64.GB * task.attempt, 'memory') }
        time = { check_max(48.h * task.attempt, 'time') }
        errorStrategy = { task.exitStatus in [137,139,143,247] ? 'retry' : 'terminate' }
        maxRetries = 3
        publishDir = [
            path: { "${params.outdir}/imputed" },
            mode: params.publish_dir_mode,
            pattern: "*.dose.vcf.gz*",
            saveAs: { filename -> 
                def meta_str = "${meta.id}_${meta.chr ?: 'all'}"
                filename.replace(meta.id, meta_str)
            }
        ]
    }

    withName: 'EXTRACT_INFO_SCORES' {
        container = 'mamana/vcf-processing:bcftools-1.20'
        cpus = { check_max(4 * task.attempt, 'cpus') }
        memory = { check_max(16.GB * task.attempt, 'memory') }
        time = { check_max(4.h * task.attempt, 'time') }
        errorStrategy = 'retry'
        maxRetries = 2
        publishDir = [
            path: { "${params.outdir}/imputed/info_scores" },
            mode: params.publish_dir_mode,
            pattern: "*.{txt,tsv,csv}"
        ]
    }
    
    withName: 'FILTER_IMPUTED' {
        container = 'mamana/vcf-processing:bcftools-1.20'
        ext.args = '--threads 8'
        cpus = { check_max(8 * task.attempt, 'cpus') }
        memory = { check_max(32.GB * task.attempt, 'memory') }
        time = { check_max(8.h * task.attempt, 'time') }
        errorStrategy = { task.exitStatus in [137,139,143,247] ? 'retry' : 'terminate' }
        maxRetries = 2
        publishDir = [
            path: { "${params.outdir}/imputed/filtered" },
            mode: params.publish_dir_mode,
            pattern: "*.filtered.vcf.gz*"
        ]
    }

    withName: 'IMPUTE5_IMPUTE' {
        container = 'mamana/imputation:minimac4-4.1.6'
        ext.args = '--out-gp-field --out-ap-field --threads 8'
        cpus = { check_max(8 * task.attempt, 'cpus') }
        memory = { check_max(32.GB * task.attempt, 'memory') }
        time = { check_max(24.h * task.attempt, 'time') }
        errorStrategy = { task.exitStatus in [137,139,143,247] ? 'retry' : 'terminate' }
        maxRetries = 3
        publishDir = [
            path: { "${params.outdir}/imputed/impute5" },
            mode: params.publish_dir_mode,
            pattern: "*.vcf.gz*"
        ]
    }

    withName: 'BEAGLE5_IMPUTE' {
        container = 'mamana/phasing:beagle-5.4'
        ext.args = 'gp=true ap=true nthreads=12'
        cpus = { check_max(12 * task.attempt, 'cpus') }
        memory = { check_max(48.GB * task.attempt, 'memory') }
        time = { check_max(36.h * task.attempt, 'time') }
        errorStrategy = { task.exitStatus in [137,139,143,247] ? 'retry' : 'terminate' }
        maxRetries = 3
        publishDir = [
            path: { "${params.outdir}/imputed/beagle5" },
            mode: params.publish_dir_mode,
            pattern: "*.vcf.gz*"
        ]
    }

    // VCF chunking and processing (requires bcftools)
    withName: 'CREATE_CHUNK_LIST' {
        container = 'mamana/vcf-processing:bcftools-1.20'
        cpus = { check_max(2 * task.attempt, 'cpus') }
        memory = { check_max(8.GB * task.attempt, 'memory') }
        time = { check_max(2.h * task.attempt, 'time') }
        errorStrategy = 'retry'
        maxRetries = 2
        publishDir = [
            path: { "${params.outdir}/chunks" },
            mode: params.publish_dir_mode,
            pattern: "*.{txt}"
        ]
    }
    
    withName: 'EXTRACT_VCF_CHUNK' {
        container = 'mamana/vcf-processing:bcftools-1.20'
        ext.args = '--output-type z --threads 4'
        cpus = { check_max(4 * task.attempt, 'cpus') }
        memory = { check_max(16.GB * task.attempt, 'memory') }
        time = { check_max(4.h * task.attempt, 'time') }
        errorStrategy = { task.exitStatus in [137,139,143,247] ? 'retry' : 'terminate' }
        maxRetries = 3
        publishDir = [
            path: { "${params.outdir}/chunks" },
            mode: params.publish_dir_mode,
            pattern: "*.vcf.gz*"
        ]
    }
    
    withName: 'CHECK_CHUNK_OVERLAP' {
        container = 'mamana/vcf-processing:bcftools-1.20'
        cpus = { check_max(4 * task.attempt, 'cpus') }
        memory = { check_max(16.GB * task.attempt, 'memory') }
        time = { check_max(4.h * task.attempt, 'time') }
        errorStrategy = 'retry'
        maxRetries = 2
        publishDir = [
            path: { "${params.outdir}/chunks/overlap" },
            mode: params.publish_dir_mode,
            pattern: "*.txt"
        ]
    }
    
    withName: 'EXTRACT_REFERENCE_CHUNK' {
        container = 'mamana/vcf-processing:bcftools-1.20'
        ext.args = '--output-type z --threads 4'
        cpus = { check_max(4 * task.attempt, 'cpus') }
        memory = { check_max(16.GB * task.attempt, 'memory') }
        time = { check_max(4.h * task.attempt, 'time') }
        errorStrategy = 'retry'
        maxRetries = 2
        publishDir = [
            path: { "${params.outdir}/chunks/reference" },
            mode: params.publish_dir_mode,
            pattern: "*.vcf.gz*"
        ]
    }
    
    // Processes requiring both Python and bcftools
    withName: 'CHUNK_GENOME' {
        container = 'mamana/vcf-processing:bcftools-1.20'
        cpus = { check_max(2 * task.attempt, 'cpus') }
        memory = { check_max(8.GB * task.attempt, 'memory') }
        time = { check_max(2.h * task.attempt, 'time') }
        errorStrategy = 'retry'
        maxRetries = 2
        publishDir = [
            path: { "${params.outdir}/chunks/genome" },
            mode: params.publish_dir_mode,
            pattern: "*.bed"
        ]
    }
    
    withName: 'SPLIT_VCF_CHUNKS' {
        container = 'mamana/vcf-processing:bcftools-1.20'
        ext.args = '--threads 4'
        cpus = { check_max(4 * task.attempt, 'cpus') }
        memory = { check_max(16.GB * task.attempt, 'memory') }
        time = { check_max(6.h * task.attempt, 'time') }
        errorStrategy = { task.exitStatus in [137,139,143,247] ? 'retry' : 'terminate' }
        maxRetries = 3
        publishDir = [
            path: { "${params.outdir}/chunks/split" },
            mode: params.publish_dir_mode,
            pattern: "*.vcf.gz*"
        ]
    }
    
    withName: 'MERGE_LOW_OVERLAP_CHUNKS' {
        container = 'mamana/vcf-processing:bcftools-1.20'
        ext.args = '--threads 8'
        cpus = { check_max(8 * task.attempt, 'cpus') }
        memory = { check_max(32.GB * task.attempt, 'memory') }
        time = { check_max(8.h * task.attempt, 'time') }
        errorStrategy = { task.exitStatus in [137,139,143,247] ? 'retry' : 'terminate' }
        maxRetries = 2
        publishDir = [
            path: { "${params.outdir}/chunks/merged" },
            mode: params.publish_dir_mode,
            pattern: "*.vcf.gz*"
        ]
    }
    
    // Overlap reporting
    withName: 'AGGREGATE_OVERLAP_REPORTS' {
        container = 'mamana/python-plotting:1.1.0'
        cpus = { check_max(4 * task.attempt, 'cpus') }
        memory = { check_max(16.GB * task.attempt, 'memory') }
        time = { check_max(4.h * task.attempt, 'time') }
        errorStrategy = 'retry'
        maxRetries = 2
        publishDir = [
            path: { "${params.outdir}/qc/overlap_reports" },
            mode: params.publish_dir_mode,
            pattern: "*.{txt,csv,json}"
        ]
    }

    // Reporting and visualization modules
    withName: 'CALCULATE_METRICS|CALCULATE_IMPUTATION_METRICS' {
        container = 'mamana/python-plotting:1.1.0'
        cpus = { check_max(4 * task.attempt, 'cpus') }
        memory = { check_max(16.GB * task.attempt, 'memory') }
        time = { check_max(6.h * task.attempt, 'time') }
        errorStrategy = 'retry'
        maxRetries = 2
        publishDir = [
            path: { "${params.outdir}/metrics" },
            mode: params.publish_dir_mode,
            pattern: "*.{json,tsv,txt,csv}"
        ]
    }

    // Reserved for future reporting modules
    // withName: 'ACCURACY_REPORT|PERFORMANCE_REPORT|HTML_REPORT|MULTIQC_CONFIG' {
    //     container = 'mamana/python-plotting:latest'
    //     cpus = 1
    //     memory = 4.GB
    //     publishDir = [
    //         path: { "${params.outdir}/reports" },
    //         mode: params.publish_dir_mode,
    //         pattern: "*.{html,pdf,png}"
    //     ]
    // }

    withName: 'PLOT_INFO_DISTRIBUTION|PLOT_MAF_CONCORDANCE|PLOT_R2_POSITION|PLOT_QC_METRICS|PLOT_IMPUTATION_QUALITY' {
        container = 'mamana/python-plotting:1.1.0'
        cpus = { check_max(2 * task.attempt, 'cpus') }
        memory = { check_max(8.GB * task.attempt, 'memory') }
        time = { check_max(3.h * task.attempt, 'time') }
        errorStrategy = 'retry'
        maxRetries = 2
        publishDir = [
            path: { "${params.outdir}/plots" },
            mode: params.publish_dir_mode,
            pattern: "*.{png,pdf,svg,jpg}"
        ]
    }

    withName: 'CREATE_HTML_REPORT|GENERATE_MULTIQC_REPORT' {
        container = 'mamana/python-plotting:1.1.0'
        cpus = { check_max(4 * task.attempt, 'cpus') }
        memory = { check_max(16.GB * task.attempt, 'memory') }
        time = { check_max(4.h * task.attempt, 'time') }
        errorStrategy = 'retry'
        maxRetries = 2
        publishDir = [
            path: { "${params.outdir}" },
            mode: params.publish_dir_mode,
            pattern: "*.html",
            saveAs: { filename -> 
                filename.contains('multiqc') ? "multiqc_report.html" : "imputation_report.html"
            }
        ]
    }

    // nf-core modules
    withName: 'CUSTOM_DUMPSOFTWAREVERSIONS' {
        container = 'mamana/python-plotting:1.1.0'
        cpus = 1
        memory = { check_max(2.GB * task.attempt, 'memory') }
        time = { check_max(1.h * task.attempt, 'time') }
        errorStrategy = 'retry'
        maxRetries = 2
        publishDir = [
            path: { "${params.outdir}/pipeline_info" },
            mode: params.publish_dir_mode,
            pattern: "*.{yml,tsv}"
        ]
    }
    
    // VCF format conversion and validation
    withName: 'CONVERT_TO_PLINK|CONVERT_TO_BCF|VALIDATE_VCF_FORMAT' {
        container = 'mamana/vcf-processing:bcftools-1.20'
        cpus = { check_max(4 * task.attempt, 'cpus') }
        memory = { check_max(16.GB * task.attempt, 'memory') }
        time = { check_max(4.h * task.attempt, 'time') }
        errorStrategy = 'retry'
        maxRetries = 2
        publishDir = [
            path: { "${params.outdir}/converted" },
            mode: params.publish_dir_mode,
            pattern: "*.{bed,bim,fam,bcf,csi}"
        ]
    }
    
    // Concordance and comparison analyses
    withName: 'CALCULATE_CONCORDANCE|COMPARE_VARIANTS|MERGE_CONCORDANCE_REPORTS' {
        container = 'mamana/vcf-processing:bcftools-1.20'
        cpus = { check_max(8 * task.attempt, 'cpus') }
        memory = { check_max(32.GB * task.attempt, 'memory') }
        time = { check_max(8.h * task.attempt, 'time') }
        errorStrategy = { task.exitStatus in [137,139,143,247] ? 'retry' : 'terminate' }
        maxRetries = 2
        publishDir = [
            path: { "${params.outdir}/concordance" },
            mode: params.publish_dir_mode,
            pattern: "*.{txt,tsv,vcf.gz*}"
        ]
    }

    // Resource limits for all processes with progressive retry scaling
    withLabel: 'process_single' {
        cpus = { check_max(1, 'cpus') }
        memory = { check_max(2.GB * Math.pow(2, task.attempt - 1), 'memory') }
        time = { check_max(2.h * task.attempt, 'time') }
        errorStrategy = { task.exitStatus in [137,139,143,247] ? 'retry' : 'ignore' }
        maxRetries = 2
    }

    withLabel: 'process_low' {
        cpus = { check_max(2 * task.attempt, 'cpus') }
        memory = { check_max(4.GB * Math.pow(2, task.attempt - 1), 'memory') }
        time = { check_max(4.h * task.attempt, 'time') }
        errorStrategy = { task.exitStatus in [137,139,143,247] ? 'retry' : 'finish' }
        maxRetries = 2
    }

    withLabel: 'process_medium' {
        cpus = { check_max(4 * task.attempt, 'cpus') }
        memory = { check_max(8.GB * Math.pow(2, task.attempt - 1), 'memory') }
        time = { check_max(8.h * task.attempt, 'time') }
        errorStrategy = { task.exitStatus in [137,139,143,247] ? 'retry' : 'finish' }
        maxRetries = 3
    }

    withLabel: 'process_high' {
        cpus = { check_max(8 * task.attempt, 'cpus') }
        memory = { check_max(16.GB * Math.pow(2, task.attempt - 1), 'memory') }
        time = { check_max(16.h * task.attempt, 'time') }
        errorStrategy = { task.exitStatus in [137,139,143,247] ? 'retry' : 'terminate' }
        maxRetries = 3
    }

    withLabel: 'process_long' {
        cpus = { check_max(8, 'cpus') }
        memory = { check_max(32.GB * Math.pow(2, task.attempt - 1), 'memory') }
        time = { check_max(24.h * task.attempt, 'time') }
        errorStrategy = { task.exitStatus in [137,139,143,247] ? 'retry' : 'terminate' }
        maxRetries = 2
    }

    withLabel: 'process_high_memory' {
        cpus = { check_max(12, 'cpus') }
        memory = { check_max(32.GB * Math.pow(2, task.attempt - 1), 'memory') }
        time = { check_max(24.h * task.attempt, 'time') }
        errorStrategy = { task.exitStatus in [137,139,143,247] ? 'retry' : 'terminate' }
        maxRetries = 3
    }

    // Error handling
    withLabel: 'error_ignore' {
        errorStrategy = 'ignore'
    }

    withLabel: 'error_retry' {
        errorStrategy = 'retry'
        maxRetries = 2
    }
    
    // Sample processing and indexing
    withName: 'INDEX_VCF|INDEX_BCF|TABIX_VCF' {
        container = 'mamana/vcf-processing:bcftools-1.20'
        cpus = { check_max(2 * task.attempt, 'cpus') }
        memory = { check_max(4.GB * task.attempt, 'memory') }
        time = { check_max(2.h * task.attempt, 'time') }
        errorStrategy = 'retry'
        maxRetries = 2
    }
    
    withName: 'EXTRACT_SAMPLES|SUBSET_SAMPLES|MERGE_SAMPLES' {
        container = 'mamana/vcf-processing:bcftools-1.20'
        ext.args = '--threads 4'
        cpus = { check_max(4 * task.attempt, 'cpus') }
        memory = { check_max(16.GB * task.attempt, 'memory') }
        time = { check_max(6.h * task.attempt, 'time') }
        errorStrategy = { task.exitStatus in [137,139,143,247] ? 'retry' : 'terminate' }
        maxRetries = 2
    }
    
    // Statistics and summary generation
    withName: 'CALCULATE_STATS|GENERATE_SUMMARY|VCF_STATS' {
        container = 'mamana/vcf-processing:bcftools-1.20'
        cpus = { check_max(4 * task.attempt, 'cpus') }
        memory = { check_max(16.GB * task.attempt, 'memory') }
        time = { check_max(4.h * task.attempt, 'time') }
        errorStrategy = 'retry'
        maxRetries = 2
        publishDir = [
            path: { "${params.outdir}/stats" },
            mode: params.publish_dir_mode,
            pattern: "*.{txt,json,tsv}"
        ]
    }
}

// Function to ensure resource requirements don't exceed maximums
def check_max(obj, type) {
    if (type == 'memory') {
        try {
            if (obj.compareTo(params.max_memory as nextflow.util.MemoryUnit) == 1)
                return params.max_memory as nextflow.util.MemoryUnit
            else
                return obj
        } catch (all) {
            println "   ### ERROR ###   Max memory '${params.max_memory}' is not valid! Using default value: $obj"
            return obj
        }
    } else if (type == 'cpus') {
        try {
            return Math.min(obj, params.max_cpus as int)
        } catch (all) {
            println "   ### ERROR ###   Max cpus '${params.max_cpus}' is not valid! Using default value: $obj"
            return obj
        }
    } else if (type == 'time') {
        try {
            if (obj.compareTo(params.max_time as nextflow.util.Duration) == 1)
                return params.max_time as nextflow.util.Duration
            else
                return obj
        } catch (all) {
            println "   ### ERROR ###   Max time '${params.max_time}' is not valid! Using default value: $obj"
            return obj
        }
    }
}