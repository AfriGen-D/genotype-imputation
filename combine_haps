#!/usr/bin/perl
# combine_haps combines imputed haplotype files
# and is released under the terms of the GNU GPL version 3, or any
# later version, at your option. See the file README and COPYING for
# more information.
# Copyright 2017 by Don Armstrong <don@donarmstrong.com>.


use warnings;
use strict;

use Getopt::Long;
use Pod::Usage;

use Scalar::Util qw(looks_like_number);

=head1 NAME

combine_haps - combines imputed haplotype files

=head1 SYNOPSIS

combine_haps [options]

 Options:
   --debug, -d debugging level (Default 0)
   --help, -h display this help
   --man, -m display manual

=head1 OPTIONS

=over

=item B<--output-file>

Output filename

=item B<--compress>

Whether to compress output using gzip (or xz or bzip2); default on

=item B<--debug, -d>

Debug verbosity. (Default 0)

=item B<--help, -h>

Display brief usage information.

=item B<--man, -m>

Display this manual.

=back

=head1 EXAMPLES

combine_haps

=cut


use vars qw($DEBUG);

my %options = (debug           => 0,
               help            => 0,
               man             => 0,
               null            => 0,
               # compress        => 1,
              );

GetOptions(\%options,
           # 'compress!',
           'null|0',
           'output_file|output-file=s',
           'debug|d+','help|h|?','man|m');

pod2usage() if $options{help};
pod2usage({verbose=>2}) if $options{man};

$DEBUG = $options{debug};

my @USAGE_ERRORS;
# if (1) {
#     push @USAGE_ERRORS,"You must pass something";
# }

pod2usage(join("\n",@USAGE_ERRORS)) if @USAGE_ERRORS;


my @input_files = identify_input_files(\%options);

my $haps = read_input_haps(\@input_files);

$haps = sort_and_remove_duplicate_haps($haps);

# $haps = sort_input_haps($haps);

write_input_haps(\%options,$haps);


sub identify_input_files {
    my ($options) = @_;

    if ($options->{null}) {
        local $/ = "\0"
    }
    my @files;
    while (<>) {
        if ($options->{null}) {
            s/\0$//;
        } else {
            chomp
        }
        push @files,$_;
    }
    return @files;
}

sub read_input_haps {
    my ($input_files) = @_;

    sub read_input_hap {
        my ($file) = @_;
        my $fh;
        open($fh,'<',$file) or
            die "Unable to open $file for reading: $!";
        my $res = {};
        while (<$fh>) {
            chomp;
            my ($chr,$rs,$pos,$stuff) = split /\s+/,$_,4;
            if ($chr eq '---') {
                ($chr) = $rs =~ /^([^:]+)\:/;
            }
            next unless defined $chr and defined $pos;
            $res->{chr} = $chr;
            $res->{pos} = $pos;
            $res->{file} = $file;
            $res->{size} = (stat $file)[7];
            last;
        }
        close($fh);
        return $res;
    }
    my @haps;
    for my $f (@{$input_files}) {
        my $h = read_input_hap($f);
        next unless defined $h->{chr};
        push @haps,$h;
    }
    return \@haps;
}

sub sort_and_remove_duplicate_haps {
    my ($haps) = @_;

    my %haps;
    for my $h (@{$haps}) {
        if (exists $haps{$h->{chr}}{$h->{pos}}) {
            next if $h->{size} <= $haps{$h->{chr}}{$h->{pos}}{size};
        }
        $haps{$h->{chr}}{$h->{pos}} = $h;
    }
    my @haps;
    for my $chr (sort {sort_semi_num($a,$b)} keys %haps) {
        for my $pos (sort {$a <=> $b} keys %{$haps{$chr}}) {
            push @haps,$haps{$chr}{$pos};
        }
    }
    return \@haps;
}


sub sort_semi_num {
    my ($a,$b) = @_;
    if (looks_like_number($a) and looks_like_number($b)) {
        return $a <=> $b;
    } else {
        return $a cmp $b;
    }
}

sub sort_input_haps {
    my ($haps) = @_;

    my @haps = sort { sort_semi_num($a->{chr},$b->{chr}) ||
                          $a->{pos} <=> $b->{pos}
                      } @{$haps};
    return \@haps;
}

sub write_input_haps {
    my ($options,$haps) = @_;

    # open output file
    my $fh;
    if (defined $options->{output_file}) {
        open($fh,'>',$options->{output_file});
    } else {
       $fh = \*STDOUT;
    }
    for my $h (@{$haps}) {
        my $hap_fh;
        open($hap_fh,'<',$h->{file}) or
            die "Unable to open $h->{file} for reading: $!";
        local $/;
        print {$fh} <$hap_fh>;
        close($hap_fh);
    }
    close($fh);
}


__END__
